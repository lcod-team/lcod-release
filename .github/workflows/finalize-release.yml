name: Finalize Release Cascade

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Target semantic version (ex: 0.1.16)"
        required: true

jobs:
  verify-prs:
    name: Verify release PRs merged
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - repo: lcod-team/lcod-kernel-rs
            name: lcod-kernel-rs
          - repo: lcod-team/lcod-kernel-js
            name: lcod-kernel-js
          - repo: lcod-team/lcod-kernel-java
            name: lcod-kernel-java
          - repo: lcod-team/lcod-cli
            name: lcod-cli
    steps:
      - name: Check PR state
        env:
          VERSION: ${{ inputs.version }}
          GH_TOKEN: ${{ secrets.LCOD_RELEASE_TOKEN }}
          REPO: ${{ matrix.repo }}
          NAME: ${{ matrix.name }}
        run: |
          branch="release/v${VERSION}"
          data="$(gh pr list --repo "${REPO}" --head "${branch}" --state all --json number,state,url --limit 1)"
          if [[ -z "${data}" || "${data}" == "[]" ]]; then
            echo "::error::No PR found on ${REPO} with head ${branch}" >&2
            exit 1
          fi
          state="$(echo "${data}" | jq -r '.[0].state')"
          url="$(echo "${data}" | jq -r '.[0].url')"
          if [[ "${state}" != "MERGED" ]]; then
            echo "::error::PR ${url} is not merged (state=${state})" >&2
            exit 1
          fi
          echo "- ${NAME}: ${url} merged" >> "$GITHUB_STEP_SUMMARY"

  tag-repositories:
    name: Tag repositories
    runs-on: ubuntu-latest
    needs: verify-prs
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: lcod-kernel-rs
            repo: lcod-team/lcod-kernel-rs
            tag_prefix: lcod-run-v
            message_prefix: "lcod-run "
          - name: lcod-kernel-js
            repo: lcod-team/lcod-kernel-js
            tag_prefix: v
            message_prefix: "lcod-kernel-js "
          - name: lcod-kernel-java
            repo: lcod-team/lcod-kernel-java
            tag_prefix: v
            message_prefix: "lcod-kernel-java "
          - name: lcod-cli
            repo: lcod-team/lcod-cli
            tag_prefix: v
            message_prefix: "lcod-cli "
    steps:
      - name: Checkout ${{ matrix.repo }}
        uses: actions/checkout@v4
        with:
          repository: ${{ matrix.repo }}
          token: ${{ secrets.LCOD_RELEASE_TOKEN }}
          fetch-depth: 0

      - name: Configure author
        run: |
          git config user.name "lcod-release-bot"
          git config user.email "releases@lcod.team"

      - name: Create and push tag
        env:
          VERSION: ${{ inputs.version }}
          TAG_PREFIX: ${{ matrix.tag_prefix }}
          MESSAGE_PREFIX: ${{ matrix.message_prefix }}
        run: |
          tag="${TAG_PREFIX}${VERSION}"
          if git rev-parse "refs/tags/${tag}" >/dev/null 2>&1; then
            echo "- ${{ matrix.repo }}: tag ${tag} already exists" >> "$GITHUB_STEP_SUMMARY"
            exit 0
          fi

          git tag -a "${tag}" -m "${MESSAGE_PREFIX}${VERSION}"
          git push origin "${tag}"
          echo "- ${{ matrix.repo }}: created ${tag}" >> "$GITHUB_STEP_SUMMARY"

  aggregate-release:
    name: Aggregate release assets
    runs-on: ubuntu-latest
    needs: tag-repositories
    steps:
      - name: Checkout lcod-release
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.LCOD_RELEASE_TOKEN }}

      - name: Wait for repository releases
        env:
          VERSION: ${{ inputs.version }}
          GH_TOKEN: ${{ secrets.LCOD_RELEASE_TOKEN }}
        run: |
          repos=(
            "lcod-team/lcod-kernel-rs"
            "lcod-team/lcod-kernel-js"
            "lcod-team/lcod-kernel-java"
            "lcod-team/lcod-cli"
          )
          tags=(
            "lcod-run-v${VERSION}"
            "v${VERSION}"
            "v${VERSION}"
            "v${VERSION}"
          )
          for i in "${!repos[@]}"; do
            repo="${repos[$i]}"
            tag="${tags[$i]}"
            attempts=0
            until gh release view "${tag}" --repo "${repo}" >/dev/null 2>&1; do
              attempts=$((attempts + 1))
              if [ "${attempts}" -ge 40 ]; then
                echo "Timed out waiting for release ${tag} in ${repo}" >&2
                exit 1
              fi
              echo "Waiting for ${tag} in ${repo}..."
              sleep 30
            done
          done

      - name: Download release artefacts
        env:
          VERSION: ${{ inputs.version }}
          GH_TOKEN: ${{ secrets.LCOD_RELEASE_TOKEN }}
        run: |
          mkdir -p dist/rs dist/js dist/java dist/cli
          gh release download "lcod-run-v${VERSION}" \
            --repo lcod-team/lcod-kernel-rs \
            --dir dist/rs \
            --clobber
          gh release download "v${VERSION}" \
            --repo lcod-team/lcod-kernel-js \
            --dir dist/js \
            --clobber
          gh release download "v${VERSION}" \
            --repo lcod-team/lcod-kernel-java \
            --dir dist/java \
            --clobber
          gh release download "v${VERSION}" \
            --repo lcod-team/lcod-cli \
            --dir dist/cli \
            --clobber

      - name: Generate manifest
        env:
          VERSION: ${{ inputs.version }}
          GH_TOKEN: ${{ secrets.LCOD_RELEASE_TOKEN }}
        run: |2
          mkdir -p dist
          python <<'PY'
  import json
  import os
  import subprocess

  def release_info(repo: str, tag: str):
    data = json.loads(subprocess.check_output(["gh", "api", f"repos/{repo}/releases/tags/{tag}"]))
    return {
      "repo": repo,
      "tag": tag,
      "url": data.get("html_url"),
      "assets": [
        {
          "name": asset["name"],
          "size": asset["size"],
          "download_url": asset["browser_download_url"],
          "content_type": asset.get("content_type"),
        }
        for asset in data.get("assets", [])
      ],
    }

  version = os.environ["VERSION"]
  manifest = {
    "version": version,
    "kernels": {
      "rs": release_info("lcod-team/lcod-kernel-rs", f"lcod-run-v{version}"),
      "js": release_info("lcod-team/lcod-kernel-js", f"v{version}"),
      "java": release_info("lcod-team/lcod-kernel-java", f"v{version}"),
    },
    "cli": release_info("lcod-team/lcod-cli", f"v{version}"),
  }

  with open("dist/release-manifest.json", "w", encoding="utf-8") as fh:
    json.dump(manifest, fh, indent=2)
    fh.write("\n")
PY


      - name: Create aggregated release
        env:
          VERSION: ${{ inputs.version }}
          GH_TOKEN: ${{ secrets.LCOD_RELEASE_TOKEN }}
        run: |
          mapfile -t FILES < <(find dist -type f -print)
          if [ "${#FILES[@]}" -eq 0 ]; then
            echo "No artefacts downloaded; aborting."
            exit 1
          fi

          notes="Aggregated release ${VERSION}

Included artefacts:
- lcod-kernel-rs (lcod-run-v${VERSION})
- lcod-kernel-js (v${VERSION})
- lcod-kernel-java (v${VERSION})
- lcod-cli (v${VERSION})
"

          if gh release view "v${VERSION}" >/dev/null 2>&1; then
            gh release upload "v${VERSION}" "${FILES[@]}" --clobber
            gh release edit "v${VERSION}" --notes "${notes}"
          else
            gh release create "v${VERSION}" "${FILES[@]}" --title "LCOD ${VERSION}" --notes "${notes}"
          fi

      - name: Summarise aggregated release
        env:
          VERSION: ${{ inputs.version }}
        run: |
          echo "- lcod-release: published aggregated release v${VERSION}" >> "$GITHUB_STEP_SUMMARY"
